{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/input-output-redirection-to-same-file-in-bash","result":{"data":{"markdownRemark":{"id":"5a034ed6-8756-5c4e-b71c-0242a92a04c6","html":"<p>이 포스트는 GNU bash, version 3.2.57(1)-release 환경에서 작성되었습니다.</p>\n<p>Bash에서 standard I/O은 파일로 redirection될 수 있습니다. 아래와 같이 말이죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cat</span> infile\n<span class=\"token comment\"># The sed utility reads the specified files, or the standard input if no files are specified, modifying the input as specified by a list of commands.</span>\n\n<span class=\"token comment\"># the를 The로 바꾸는 커맨드</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'s/the/The/g'</span> <span class=\"token operator\">&lt;</span> infile <span class=\"token operator\">></span> outfile</code></pre></div>\n<p>워 스크립트에서는 stdin을 infile에 연결하여 sed에 대한 입력으로 사용하고, stdout을 outfile에 연결하여 sed의 출력이 outfile에 저장됩니다.</p>\n<p>저는 여기서 ‘결과를 infile 자체에 저장하고 싶은데 과연 입출력을 한 파일로 동시에 redirection 할 수 있을까?’ 라는 의문이 들었습니다.\n이 포스트는 이 질문에서 시작합니다.</p>\n<h2 id=\"단순하게-시도하기\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%88%9C%ED%95%98%EA%B2%8C-%EC%8B%9C%EB%8F%84%ED%95%98%EA%B8%B0\" aria-label=\"단순하게 시도하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단순하게 시도하기</h2>\n<p>처음으로 시도한 방법은 가장 직관적인 방법이었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'s/the/The/g'</span> <span class=\"token operator\">&lt;</span> infile <span class=\"token operator\">></span> infile\n<span class=\"token function\">cat</span> infile          <span class=\"token comment\"># 아무 것도 출력되지 않습니다.</span></code></pre></div>\n<p>하지만 예상한 바와는 다르게 infile에는 아무 것도 출력되지 않은 것을 알 수 있습니다.</p>\n<h2 id=\"왜-안-될까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%95%88-%EB%90%A0%EA%B9%8C\" aria-label=\"왜 안 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 안 될까?</h2>\n<p>이를 설명하기 위해서는 Bash에 대해 조금은 깊숙히 다룰 필요가 있습니다.</p>\n<p>Bash는 C로 작성된 프로그램입니다.<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 이는 redirection 처리가 내부적으로 C에 의해 이루어진다는 의미입니다.\n위 sed 커맨드는 내부적으로 대략 이렇게 처리된다고 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// infile을 \"w\"모드로 open 합니다.</span>\n<span class=\"token keyword\">int</span> fd1 <span class=\"token operator\">=</span> <span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"infile\"</span><span class=\"token punctuation\">,</span> O_TRUNC<span class=\"token operator\">|</span>O_WRONLY<span class=\"token operator\">|</span>O_CREAT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// infile을 \"r\"모드로 open 합니다.</span>\n<span class=\"token keyword\">int</span> fd2 <span class=\"token operator\">=</span> <span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"infile\"</span><span class=\"token punctuation\">,</span> O_RDONLY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 파일 디스크립터 0을 표준 입력에서 fd1로 변경합니다.</span>\n<span class=\"token function\">dup2</span><span class=\"token punctuation\">(</span>fd1<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 파일 디스크립터 1을 표준 출력에서 fd2로 변경합니다.</span>\n<span class=\"token function\">dup2</span><span class=\"token punctuation\">(</span>fd2<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// sed 실행</span>\n<span class=\"token comment\">// sed 내에서의 입출력은 각각 파일 디스크립터 0, 1로 이뤄지므로</span>\n<span class=\"token comment\">// 결국 아래 코드는 infile로부터 입력을 받아 infile로 출력하게 됩니다.</span>\n<span class=\"token function\">sed</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그래서 왜 안 되는 걸까요? 위 코드를 우리가 실행해 볼 수 있는 수준으로 단순화해보겠습니다.</p>\n<p>우선 testfile이라는 파일을 만들고 텍스트를 넣습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello World'</span> <span class=\"token operator\">></span> testfile</code></pre></div>\n<p>그 후 같은 디렉터리에서 아래 C 코드를 작성, 컴파일한 후 실행해 봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// fopen()은 내부적으로 open()을 호출합니다.</span>\n    FILE<span class=\"token operator\">*</span> in <span class=\"token operator\">=</span> <span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"testfile\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"r\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    FILE<span class=\"token operator\">*</span> out <span class=\"token operator\">=</span> <span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"testfile\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"w\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 위 코드에서 파일 디스크립터 0, 1을 변경하는 부분을 제거하고</span>\n    <span class=\"token comment\">// 직접 파일을 열어 읽고 쓰는 식으로 바꿨습니다.</span>\n    <span class=\"token comment\">// testfile로부터 \"Hello World\"라는 문자열을 읽어 buf에 저장합니다.</span>\n    <span class=\"token function\">fgets</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// \"Hello World\"를 testfile에 씁니다.</span>\n    <span class=\"token function\">fputs</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">fclose</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">fclose</span><span class=\"token punctuation\">(</span>out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드를 실행해 보면 infile이 비어있던 것처럼 testfile도 비어있음을 확인할 수 있습니다.\n<strong>즉, 위 sed 커맨드가 생각대로 작동되지 않은 이유는 C의 open() 함수의 작동 방식 때문이었다는 것을 알 수 있습니다.</strong></p>\n<p>자, open()은 system call이므로 이제 문제가 OS로 확장되었습니다.\n이번 포스트에서는 OS까지 다룰 생각이 전혀 없으므로\n<strong>‘open() system call을 이용해 한 파일을 “r”모드와 “w”모드로 동시에 열면 문제가 생기는구나’</strong>\n정도로 이해하고 넘어가려고 합니다.</p>\n<h2 id=\"다른-방법으로-시도하기\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%A5%B8-%EB%B0%A9%EB%B2%95%EC%9C%BC%EB%A1%9C-%EC%8B%9C%EB%8F%84%ED%95%98%EA%B8%B0\" aria-label=\"다른 방법으로 시도하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다른 방법으로 시도하기</h2>\n<p>제가 원하는 결과를 얻기 위해선 어떻게 해야 할까요?</p>\n<p>구글링 해본 결과 bash의 그룹 커맨드 { }와 rm을 이용하면 standard I/O을 하나의 파일로 동시에 redirection할 수 있다는 사실을 발견했습니다.\n아래와 같이 말이죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">{</span> <span class=\"token function\">rm</span> -f infile<span class=\"token punctuation\">;</span> <span class=\"token function\">sed</span> <span class=\"token string\">'s/the/The/g'</span> <span class=\"token operator\">></span> infile <span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">&lt;</span> infile\n<span class=\"token function\">cat</span> infile</code></pre></div>\n<p>위 커맨드는 제가 원하던 결과를 출력합니다. 하지만 rm 커맨드를 사용하는 부분이 조금 찝찝합니다.\n위 커맨드를 실행하기 전과 후의 infile가 서로 같은 파일이라면 rm 커맨드는 실행되지 않은 걸까요?\n정말 입력에 사용한 infile과 출력에 사용한 infile이 같은 파일인지 한 번 확인해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># infile의 inode 값을 출력합니다.</span>\n<span class=\"token comment\"># 여기서 inode 값은 파일에 대한 식별자라고 할 수 있습니다.</span>\n<span class=\"token function\">stat</span> -f %i infile\n<span class=\"token punctuation\">{</span> <span class=\"token function\">rm</span> -f infile<span class=\"token punctuation\">;</span> <span class=\"token function\">sed</span> <span class=\"token string\">'s/the/The/g'</span> <span class=\"token operator\">></span> infile <span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">&lt;</span> infile\n<span class=\"token function\">stat</span> -f %i infile</code></pre></div>\n<p>위 커맨드를 실행해보면 2번째 커맨드를 실행하기 전후 infile의 inode<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> 값이 변경되었음을 확인할 수 있습니다.\n<strong>즉, 이는 입력은 기존의 infile을 사용했지만, 출력은 이름만 infile인 다른 파일을 사용했다는 것을 의미합니다.</strong></p>\n<p>여기서 눈여겨 볼 점은 그룹 커맨드 안에서 infile이 이미 삭제되었음에도 불구하고 sed에 대한 입력은 여전히 삭제된 infile로 연결되어 있다는 점입니다.</p>\n<h2 id=\"왜-될까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EB%90%A0%EA%B9%8C\" aria-label=\"왜 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 될까?</h2>\n<p>위 커맨드가 어떤 순서로 진행되는 지 천천히 살펴보겠습니다.</p>\n<ol>\n<li>그룹 커맨드를 실행하기 전에 input redirection을 먼저 처리합니다. 그룹 커맨드의 입력은 infile로 redirection됩니다.</li>\n<li>rm -f infile이 실행되어 infile이 삭제됩니다.</li>\n<li>infile이 삭제되었음에도 불구하고 sed 커맨드의 입력은 그룹 커맨드 밖에서 redirection했던 infile에서 읽어옵니다.</li>\n<li>sed 커맨드가 실행됩니다.</li>\n<li>sed 커맨드의 출력은 infile로 redirection됩니다. 이 때, infile이라는 파일이 없으므로 새로 생성됩니다.</li>\n</ol>\n<p>3번이 별로 직관적이지 않아 보입니다. C에서는 어떻게 동작할 지 실습을 한 번 해보곘습니다.</p>\n<p>이전과 같이 먼저 testfile을 만들고,</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Hello World'</span> <span class=\"token operator\">></span> testfile</code></pre></div>\n<p>아래의 C코드를 작성, 컴파일한 후 실행해 봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// fopen()은 내부적으로 open()을 호출합니다.</span>\n    FILE<span class=\"token operator\">*</span> in <span class=\"token operator\">=</span> <span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"testfile\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"r\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    FILE<span class=\"token operator\">*</span> out<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// testfile을 삭제합니다.</span>\n    <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"testfile\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    out <span class=\"token operator\">=</span> <span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"testfile\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"w\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// testfile로부터 \"Hello World\"라는 문자열을 읽어 buf에 저장합니다.</span>\n    <span class=\"token function\">fgets</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// \"Hello World\"를 testfile에 씁니다.</span>\n    <span class=\"token function\">fputs</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">fclose</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">fclose</span><span class=\"token punctuation\">(</span>out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>실행해 보면 testfile에 “Hello World”가 저장되어 있음을 확인할 수 있습니다. 역시 이 정도의 결론을 내릴 수 있습니다.</p>\n<p><strong>‘아, open() system call로 파일을 “r”모드로 열었다면 그 파일을 삭제해도 입력을 처리할 수 있구나’</strong></p>\n<h2 id=\"사실\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%8B%A4\" aria-label=\"사실 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사실…</h2>\n<p>사실 infile 내에서 the를 The로 바꾸는 작업을 sed의 옵션을 사용해서 처리할 수 있습니다. 또한 이렇게 처리하는 것이 더 안전합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># -i 옵션은 백업 파일을 위한 확장자를 받습니다.</span>\n<span class=\"token function\">sed</span> -i.bak <span class=\"token string\">'s/the/The/g'</span> infile</code></pre></div>\n<p>참 멀리 돌아온 것 같은 기분이 드는 건 기분 탓입니다.(…)</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>GNU Bash source code:  <a href=\"https://ftp.gnu.org/gnu/bash/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ftp.gnu.org/gnu/bash/</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p><a href=\"https://ko.wikipedia.org/wiki/%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ko.wikipedia.org/wiki/%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/posts/input-output-redirection-to-same-file-in-bash","tagSlugs":["/tag/bash/","/tag/c/"]},"frontmatter":{"date":"2018-01-26T23:07:00.000Z","description":"Input output redirection to same file in bash","tags":["Bash","C"],"title":"Bash에서 입출력을 한 파일로 동시에 Redirection 하기","socialImage":null}}},"pageContext":{"slug":"/posts/input-output-redirection-to-same-file-in-bash"}},"staticQueryHashes":["251939775","3942705351","401334301"]}